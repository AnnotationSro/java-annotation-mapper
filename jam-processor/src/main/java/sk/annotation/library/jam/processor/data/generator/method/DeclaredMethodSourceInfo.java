package sk.annotation.library.jam.processor.data.generator.method;

import lombok.Getter;
import org.apache.commons.lang3.StringUtils;
import sk.annotation.library.jam.processor.Constants;
import sk.annotation.library.jam.processor.data.MapperClassInfo;
import sk.annotation.library.jam.processor.data.MethodCallApi;
import sk.annotation.library.jam.processor.data.TypeWithVariableInfo;
import sk.annotation.library.jam.processor.data.keys.MethodConfigKey;
import sk.annotation.library.jam.processor.data.mapi.MethodApiFullSyntax;
import sk.annotation.library.jam.processor.sourcewriter.ImportsTypeDefinitions;
import sk.annotation.library.jam.processor.sourcewriter.SourceGeneratorContext;
import sk.annotation.library.jam.processor.utils.NameUtils;
import sk.annotation.library.jam.processor.utils.TypeUtils;
import sk.annotation.library.jam.processor.utils.annotations.AnnotationValueUtils;
import sk.annotation.library.jam.processor.utils.annotations.data.AnnotationMapperConfig;
import sk.annotation.library.jam.utils.MapperRunCtxData;
import sk.annotation.library.jam.utils.MapperRunCtxDataHolder;

import javax.annotation.processing.ProcessingEnvironment;
import javax.lang.model.element.ExecutableElement;
import java.util.LinkedList;
import java.util.List;
import java.util.Objects;

/*
 Used for declaration input values, so the most important things can be wrapped
 each input method is remaked as follows:

 declared public method => mirror method, that is actually fully created

 public Obj transf(Obj in);
   => public Obj _transf(Obj in, @Return Obj ret) {....}
   implementation is :


 public Obj transf(Obj in, @Return Obj ret);
   => public Obj _transf(Obj in, @Return Obj ret) {....}


* */
public class DeclaredMethodSourceInfo extends AbstractMethodSourceInfo {

	final protected List<MethodCallApi> requiredMethods = new LinkedList<>();
	final protected ExecutableElement method;
	@Getter
	final protected MethodConfigKey methodConfigKey;
	@Getter
	final protected AnnotationMapperConfig customMethodConfig;

	public DeclaredMethodSourceInfo(MapperClassInfo ownerClassInfo, MethodApiFullSyntax methodApiParams, ProcessingEnvironment processingEnv, ExecutableElement method) {
		super(ownerClassInfo, methodApiParams);
		this.method = method;
		this.methodApiFullSyntax.getModifiers().addAll(method.getModifiers());
		super.methodApiFullSyntax.getAnnotations().getOrAddAnnotation(Constants.annotationOverride);
		this. methodConfigKey = new MethodConfigKey(ownerClassInfo.topMethodsRegistrator.registerTopMethod(method, ownerClassInfo), method, this);

		////////////////////////////////////////////////////////
		// 1)  Create MethodConfigKey
		this.customMethodConfig = AnnotationValueUtils.resolveAnnotationMapperConfig(processingEnv, method);
		if (customMethodConfig != null) {
			methodConfigKey.setWithCustomConfig(true);
			// if custom methods are here, we need to have MethodContextFeature
		}
	}

	@Override
	public void registerImports(ProcessingEnvironment processingEnv, ImportsTypeDefinitions imports) {
		super.registerImports(processingEnv, imports);
		Constants.typeMapperRunCtxDataHolder.registerImports(processingEnv, imports);
		Constants.typeMapperRunCtxData.registerImports(processingEnv, imports);
	}

	public void analyzeAndGenerateDependMethods(ProcessingEnvironment processingEnv) {
		if (!requiredMethods.isEmpty()) {
			return;
		}
		if (methodApiFullSyntax.getReturnType() == null) return; // body will be empty

		////////////////////////////////////////////////////////
		// 2)  analyze neccessary fields + return Type
		List<TypeWithVariableInfo> inputParams = methodApiFullSyntax.getRequiredParams();
		varRet = null;
		int numInputParams = inputParams.size();
		if (methodApiFullSyntax.isReturnLastParam()) {
			numInputParams--;
			varRet = inputParams.get(numInputParams);
		} else {
			String variableName = NameUtils.findBestName(methodApiFullSyntax.getParams(), "ret");
			TypeWithVariableInfo variable = new TypeWithVariableInfo(variableName, methodApiFullSyntax.getReturnType());
			varRet = new TypeWithVariableInfo(variable.getVariableName(), variable.getVariableType(), null, true);
		}

		////////////////////////////////////////////////////////
		// 3) Create neccessary transformation methods for analyzed input parameters
		for (int i = 0; i < numInputParams; i++) {

			// 3a) Create methodApiKey
			MethodCallApi methodCallApi = findOrCreateOwnMethod(processingEnv, methodConfigKey, null, inputParams.get(i).getVariableType(), varRet.getVariableType(), this.methodApiFullSyntax.isReturnLastParamRequired() || i > 0);

			if (methodCallApi == null) {
				throw new IllegalStateException("test");
			}

			// If method still doesnt exist, its wrong !!
			requiredMethods.add(methodCallApi);

			// If method is generated by us, run analysis with own settings
			if (methodCallApi.getOutGeneratedMethod() != null) {
				methodCallApi.getOutGeneratedMethod().analyzeAndGenerateDependMethods(processingEnv, methodConfigKey, this);
			}
		}


//		// Update own body
//		analyzeAndGenerateDependMethods(processingEnv, methodConfigKey, this);
	}

	@Override
	protected void analyzeAndGenerateDependMethods(ProcessingEnvironment processingEnv, MethodConfigKey forMethodConfig) {
		// nothing :)
	}

	protected void writeSourceCodeBodyReturn(SourceGeneratorContext ctx) {
		// nothing :)
	}

	@Override
	public boolean canCallInterceptors() {
		return false;
	}

	@Override
	public boolean writeSourceCode(SourceGeneratorContext ctx) {
		if (this.requiredMethods.size() == 1 && this.requiredMethods.get(0).getRowFieldGenerator()!=null) {
			methodApiFullSyntax.getRequiredParams().get(0);
			SimpleMethodApi_RowTransform_SourceInfo sourceInfo = new SimpleMethodApi_RowTransform_SourceInfo(ownerClassInfo, methodApiFullSyntax, this.requiredMethods.get(0).getRowFieldGenerator());
			sourceInfo.writeSourceCode(ctx);
//			ctx.pw.print("\nreturn " + this.requiredMethods.get(0).getRowFieldGenerator().generateRowTransform(ctx, sourceType, destinationType, methodApiFullSyntax.getRequiredParams().get(0).getVariableName()) + ";");
			return true;
		}

		if (this.unwrapModeEnabled) return false;
		return super.writeSourceCode(ctx);
	}

	@Override
	protected void writeSourceCodeBody(SourceGeneratorContext ctx) {

		// Init context ...
		List<TypeWithVariableInfo> bodyVariableNames = new LinkedList<>();
		for (TypeWithVariableInfo param : methodApiFullSyntax.getParams()) {
			usedNames.add(param.getVariableName());
			bodyVariableNames.add(param);
		}

		if (methodConfigKey != null && ownerClassInfo.getFeatures().isRequiredInputWithMethodId()) {
			bodyVariableNames.add(new TypeWithVariableInfo(methodConfigKey.getForTopMethod(), Constants.methodParamInfo_ctxForMethodId));
		}

		if (varCtxVariable == null && ownerClassInfo.getFeatures().isRequiredInputWithContextData()) {
			String bestName = NameUtils.findBestNameAndUpdateSet(usedNames, Constants.methodParamInfo_ctxForRunData.getVariableName());
			varCtxVariable = new TypeWithVariableInfo(bestName, Constants.methodParamInfo_ctxForRunData);
			bodyVariableNames.add(varCtxVariable);

			ctx.pw.print("\n");
			varCtxVariable.writeSourceCode(ctx, true, false);
			ctx.pw.print(" = ");
			if (!ownerClassInfo.getFeatures().isDisabled_SHARED_CONTEXT_DATA_IN_SUB_MAPPER()) {
				ctx.pw.print(MapperRunCtxDataHolder.class.getSimpleName());
				ctx.pw.print(".data.get();");
			} else {
				ctx.pw.print("new ");
				varCtxVariable.getVariableType().writeSourceCode(ctx);
				//ctx.pw.print(MapperRunCtxData.class.getSimpleName());
				ctx.pw.print("();");
			}
		}
		String mngCtx = null;
		if (!ownerClassInfo.getFeatures().isDisabled_SHARED_CONTEXT_DATA_IN_SUB_MAPPER()) {
			mngCtx = NameUtils.findBestNameAndUpdateSet(this.usedNames, "mng" + StringUtils.capitalize(varCtxVariable.getVariableName()));
			ctx.pw.print("\nboolean " + mngCtx + " = " + varCtxVariable.getVariableName() + "=="+ TypeUtils.createNullValue(varCtxVariable.getVariableType().getType(ctx.processingEnv))+";");
			ctx.pw.print("\n\ntry {");
			ctx.pw.levelSpaceUp();
			ctx.pw.print("\nif (" + mngCtx + ") {\n\t");
			ctx.pw.print(varCtxVariable.getVariableName());
			ctx.pw.print(" = ");
			ctx.pw.print("new " + MapperRunCtxData.class.getSimpleName() + "();");
			ctx.pw.print("\n\t" + MapperRunCtxDataHolder.class.getSimpleName() + ".data.set(" + varCtxVariable.getVariableName() + ");");
			ctx.pw.print("\n}");
		}

		// register requiredContextValues
		for (TypeWithVariableInfo ctxParam : methodApiFullSyntax.getParams()) {
			if (ctxParam.getHasContextKey() != null) {
				if (MethodCallApi.ctx_equals(Constants.methodParamInfo_ctxForRunData, ctxParam)) continue;
				ctx.pw.printNewLine();
				ctxParam.genSourceForPutContext(ctx, ctxParam.getVariableName(), this);
				ctx.pw.print(";");
			}
		}
		ctx.pw.printNewLine();

		// Call transformation methods ...
		if (!methodApiFullSyntax.isReturnLastParam()) {
			ctx.pw.print("\n");
			varRet.writeSourceCode(ctx, true, false);
			ctx.pw.print(" = "+TypeUtils.createNullValue(varRet.getVariableType().getType(ctx.processingEnv))+";");
		}

		int i = 0;
		List<TypeWithVariableInfo> inputParams = methodApiFullSyntax.getRequiredParams();
		for (MethodCallApi methodCallApi : requiredMethods) {
			// 3a) Create methodApiKey
			List<TypeWithVariableInfo> paramsForApi = new LinkedList<>();
			paramsForApi.add(inputParams.get(i++));
			paramsForApi.add(varRet);
			ctx.pw.print("\n");
			ctx.pw.print(varRet.getVariableName());
			ctx.pw.print(" = ");
			methodCallApi.genSourceForCallWithVariableParams(ctx, paramsForApi, bodyVariableNames, this);
			ctx.pw.print(";");
		}

		ctx.pw.print("\nreturn " + varRet.getVariableName() + ";");

		// clear context ...
		if (mngCtx != null && !ownerClassInfo.getFeatures().isDisabled_SHARED_CONTEXT_DATA_IN_SUB_MAPPER()) {
			ctx.pw.levelSpaceDown();
			ctx.pw.print("\n}");
			ctx.pw.print("\nfinally {");
			ctx.pw.print("\n\tif (" + mngCtx + ") " + MapperRunCtxDataHolder.class.getSimpleName() + ".data.remove();");
			ctx.pw.print("\n}\n");
		}
	}//*/


	private boolean unwrapModeEnabled = false;
	private boolean canUnwrapMethod(ProcessingEnvironment processingEnv) {
//	    if (true) return false;
		if (requiredMethods.size() != 1) return false;

		MethodCallApi methodCallApi = requiredMethods.get(0);
		if (methodCallApi.getRowFieldGenerator()!=null) return false;

		if (StringUtils.isNotEmpty(methodCallApi.getPathToSyntax())) return false;

		// ak Extended features are enabled !!!
		if (ownerClassInfo.getFeatures().isRequiredInputWithMethodId()) return false;
		if (ownerClassInfo.getFeatures().isRequiredInputWithContextData()) return false;
		if (!ownerClassInfo.getFeatures().isDisabled_SHARED_CONTEXT_DATA_IN_SUB_MAPPER()) return false;
		if (!ownerClassInfo.getFeatures().isDisabled_CYCLIC_MAPPING()) return false;
		if (methodCallApi.getOutGeneratedMethod()==null) return false;

		// ak ApiKey su rozne
		if (methodCallApi.getMethodSyntax() == null) return false;
		if (!Objects.equals(this.methodApiFullSyntax.getApiKey(), methodCallApi.getMethodSyntax().getApiKey())) return false;

		// return typ settings is different
		if (this.methodApiFullSyntax.isReturnLastParamRequired() != methodCallApi.getMethodSyntax().isReturnLastParamRequired())
			return false;

		// if unwrapped methods has multiple variants or using!
		if (methodCallApi.getOutGeneratedMethod() == this) return false;
		if (methodCallApi.getOutGeneratedMethod().hasMultipleVariants(processingEnv)) return false;
		if (methodCallApi.getOutGeneratedMethod() instanceof DeclaredMethodSourceInfo) {
//			if (!((DeclaredMethodSourceInfo)methodCallApi.getOutGeneratedMethod()).canUnwrapMethod(processingEnv)) return false;
		}

		// todo: Mali by sme testovat, ci je potrebne definovat typ metody na vstupe, lebo obsahuje @MapperConfig()

//        if (!Objects.equals(methodCallApi.getMethodSyntax().getApiKey(), this.methodApiFullSyntax.getApiKey()))
//            return;//ApiKey is the same


		// unwrap =>
		return true;
	}

	public boolean tryUnwrapMethods(ProcessingEnvironment processingEnv) {
		if (this.requiredMethods.size() == 1 && this.requiredMethods.get(0).getRowFieldGenerator()!=null) return false;

		if (!canUnwrapMethod(processingEnv)) return false;

		this.unwrapModeEnabled = true;
		MethodCallApi methodCallApi = requiredMethods.get(0);
		// unwrap =>
		methodCallApi.getMethodSyntax().setName(methodApiFullSyntax.getName());
		methodCallApi.getMethodSyntax().getAnnotations().mergeValues(methodApiFullSyntax.getAnnotations());
		methodCallApi.getMethodSyntax().getModifiers().clear();
		methodCallApi.getMethodSyntax().getModifiers().addAll(methodApiFullSyntax.getModifiers());
		methodCallApi.getMethodSyntax().getParams().clear();
		methodCallApi.getMethodSyntax().getParams().addAll(methodApiFullSyntax.getParams());
//        methodCallApi.getMethodSyntax().getParams().addAll(methodCallApi.getOutGeneratedMethod().getMethodApiFullSyntax().getParams());
//		if (methodCallApi.getMethodSyntax().isReturnLastParamRequired() != methodApiFullSyntax.isReturnLastParamRequired()) {
//			if (!methodCallApi.getMethodSyntax().isReturnLastParamRequired()) {
//				Iterator<TypeWithVariableInfo> iterator = methodCallApi.getMethodSyntax().getParams().iterator();
//				while (iterator.hasNext()) {
//					TypeWithVariableInfo next = iterator.next();
//					if (next.isMarkedAsReturn()) {
//						iterator.remove();
//						methodCallApi.getMethodSyntax().setReturnLastParam(false);
//						break;
//					}
//				}
//			}
//		}
		return true;
	}
}
